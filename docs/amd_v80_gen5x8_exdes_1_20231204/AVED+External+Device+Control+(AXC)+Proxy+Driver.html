<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/><meta content="Docutils 0.17.1: http://docutils.sourceforge.net/" name="generator"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->
<script charset="UTF-8" data-document-language="true" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" type="text/javascript"></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
<!-- Google Tag Manager -->
<script class="optanon-category-C0002" type="text/plain">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5RHQV7');</script>
<!-- End Google Tag Manager -->
<title>AVED External Device Control (AXC) Proxy Driver — AVED  documentation</title>
<link href="_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="_static/custom.css" rel="stylesheet" type="text/css"/>
<link href="_static/xbtest.css" rel="stylesheet" type="text/css"/>
<link href="_static/_static/custom.css" rel="stylesheet" type="text/css"/>
<link href="https://docs.xilinx.com/favicon.ico" rel="shortcut icon"/>
<!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
<script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
<script src="_static/jquery.js"></script>
<script src="_static/underscore.js"></script>
<script src="_static/doctools.js"></script>
<script src="_static/js/theme.js"></script>
<link href="genindex.html" rel="index" title="Index"/>
<link href="search.html" rel="search" title="Search"/>
<link href="Firmware%2BInterface%2B%28FW_IF%29%2BAbstraction%2BLayer.html" rel="next" title="Firmware Interface (FW_IF) Abstraction Layer"/>
<link href="AVED%2BSensor%2BControl%2B%28ASC%29%2BProxy%2BDriver.html" rel="prev" title="AVED Sensor Control (ASC) Proxy Driver"/>
<link href="_static/conf.css" rel="stylesheet" type="text/css"/></head>
<body class="wy-body-for-nav">
<!-- Google Tag Manager -->
<noscript><iframe class="optanon-category-C0002" height="0" src="//www.googletagmanager.com/ns.html?id=GTM-5RHQV7" style="display:none;visibility:hidden" width="0"></iframe></noscript>
<!-- End Google Tag Manager -->
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="index.html"> AVED
            <img alt="Logo" class="logo" src="_static/xilinx-header-logo.svg"/>
</a>
<div role="search">
<form action="search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div><div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<p class="caption" role="heading"><span class="caption-text">AVED v80 Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BOverview.html">AVED Overview</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">AVED Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="How-to%2Binstall%2Band%2Brun%2Ba%2Bpre-built%2BAVED%2Bdesign%2Bon%2Ban%2BALVEO%2Bcard.html">How-to install and run a pre-built AVED design on an ALVEO card</a></li>
<li class="toctree-l1"><a class="reference internal" href="How-to%2BRebuild%2Ban%2BAVED%2BDesign%2Bfor%2BYourself.html">How-to Rebuild an AVED Design for Yourself</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">AVED System Architecture</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="AVED%2B-%2BBoard%2BManagement%2BSolution.html">AVED - Board Management Solution</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2B-%2BDevice%2BProgramming.html">AVED - Device Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2B-%2BHost%2Bto%2BCard%2BCommunication.html">AVED - Host to Card Communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2B-%2BUser%2BApplication.html">AVED - User Application</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">AVED Deployment</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BDeployment%2BArchive.html">AVED Deployment Archive</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BInstalling%2Bthe%2BDeployment%2Bpackage%2Bonto%2Bthe%2BHost%2BServer.html">AVED Installing the Deployment package onto the Host Server</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BInstalling%2Bthe%2BDesign%2Bonto%2Bthe%2BCard.html">AVED Installing the Design onto the Card</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BUpdating%2BFPT%2BImage%2Bin%2BFlash.html">AVED Updating FPT Image in Flash</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BUpdating%2BDesign%2BPDI%2Bin%2BFlash.html">AVED Updating Design PDI in Flash</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BDebug%2BTechniques.html">AVED Debug Techniques</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BJTAG%2BBoot%2BRecovery.html">AVED JTAG Boot Recovery</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BManagement%2BInterface%2Buserguide%2B%28ami_tool%29.html">AVED Management Interface userguide (ami_tool)</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbtest/user-guide/source/index.html">Xbtest Userguide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BBuild%2BScripts.html">AVED Build Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="Source%2BConfiguration%2BControl.html">Source Configuration Control</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Hardware Design - V80/V80P</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BV80%26V80P%2B-%2BHierarchy%2BOverview.html">AVED V80/V80P - Hierarchy Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BV80%26V80P%2B-%2BCIPS%2BConfiguration.html">AVED V80/V80P - CIPS Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BV80%26V80P%2B-%2BMemory%2BResources.html">AVED V80/V80P - Memory Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BV80%26V80P%2B-%2BMemory%2BMap.html">AVED V80/V80P - Memory Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BV80%26V80P%2B-%2BNoC%2BConfiguration.html">AVED V80/V80P - NoC Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BV80%26V80P%2B-%2BBase%2BLogic.html">AVED V80/V80P - Base Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BV80%26V80P%2B-%2BClock%2BReset%2BModule.html">AVED V80/V80P - Clock Reset Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BV80%26V80P%2B-%2BSource%2BFile%2BOverview.html">AVED V80/V80P - Source File Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BV80%26V80P%2B-%2BXBTEST%2BDesign.html">AVED V80/V80P - XBTEST Design</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">IP</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Generic%2BCommand%2BQueue%2BIP%2Bv2.0%2B-%2BProduct%2BGuide.html">Generic Command Queue IP v2.0 - Product Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="Hardware%2BDiscovery%2BIP%2Bv1.0%2B-%2BProduct%2BGuide.html">Hardware Discovery IP v1.0 - Product Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Firmware Design - AVED</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="AVED%2BManagement%2BController%2B%28AMC%29%2B-%2BArchitecture%2Band%2BDesign.html">AVED Management Controller (AMC) - Architecture and Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BClock%2BControl%2B%28ACC%29%2BProxy%2BDriver.html">AVED Clock Control (ACC) Proxy Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BInBand%2BTelemetry%2BApplication.html">AVED InBand Telemetry Application</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BManagement%2BInterface%2B%28AMI%29%2BProxy%2BDriver.html">AVED Management Interface (AMI) Proxy Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BProgramming%2BControl%2B%28APC%29%2BProxy%2BDriver.html">AVED Programming Control (APC) Proxy Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BSensor%2BControl%2B%28ASC%29%2BProxy%2BDriver.html">AVED Sensor Control (ASC) Proxy Driver</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">AVED External Device Control (AXC) Proxy Driver</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#key-pages">Key pages</a></li>
<li class="toctree-l3"><a class="reference internal" href="#key-acronyms">Key Acronyms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#qsfp-overview">QSFP overview</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#muxed-device-fal">Muxed Device FAL</a></li>
<li class="toctree-l2"><a class="reference internal" href="#api">API</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sequence-diagrams">Sequence Diagrams</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Firmware%2BInterface%2B%28FW_IF%29%2BAbstraction%2BLayer.html">Firmware Interface (FW_IF) Abstraction Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="Operating%2BSystem%2BAbstraction%2BLayer%2B%28OSAL%29.html">Operating System Abstraction Layer (OSAL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="Profiles%2Band%2BCMake%2Bbuild%2Bprocess.html">Profiles and CMake build process</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Software Services (AMI &amp; xbtest)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BManagement%2BInterface%2B%28AMI%29.html">AVED Management Interface (AMI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbtest%2Bbuild.html">xbtest build</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="AVED%2B-%2BList%2Bof%2BAbbreviations.html">AVED - List of Abbreviations</a></li>
<li class="toctree-l1"><a class="reference internal" href="AVED%2BRelease%2BInformation.html">AVED Release Information</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift"><nav aria-label="Mobile navigation menu" class="wy-nav-top" style="background: black">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="index.html">AVED</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="Page navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a class="icon icon-home" href="index.html"></a> »</li>
<li>AVED External Device Control (AXC) Proxy Driver</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<section id="aved-external-device-control-axc-proxy-driver">
<h1>AVED External Device Control (AXC) Proxy Driver<a class="headerlink" href="#aved-external-device-control-axc-proxy-driver" title="Permalink to this headline">¶</a></h1>
<section id="overview">
<span id="avedexternaldevicecontrol-axc-proxydriver-overview"></span><h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The AXC proxy driver binds into the provided FAL for each new external device added. Internally it also creates a number of resources, including a mutex for protection and a task to check the status and temperature of each device.</p>
<p>The AXC proxy task will:</p>
<ul class="simple">
<li><p>Update the temperature value of each device.</p></li>
<li><p>Update the status (Present or not present) of each QSFP.</p></li>
<li><p>Raise an event if the QSFP status has changed (Present to not present, and vice versa).</p></li>
</ul>
<p>The Proxy APIs consist of a number of functions to set and get data from the external device memory map registers and IO expanders. Note, unlike other proxy drivers in AMC, these set/get APIs will call directly into the FAL, adding possible delays to
the calling task. The AXC proxy task will only call into the FAL to update the temperature value of each external device added.</p>
<section id="key-pages">
<span id="avedexternaldevicecontrol-axc-proxydriver-keypages"></span><h3>Key pages<a class="headerlink" href="#key-pages" title="Permalink to this headline">¶</a></h3>
<p>I2C switch (PCA9545A) data sheet: <a class="reference external" href="attachments/945057235/1060605995.pdf">PCA9545A_45B_45C.pdf</a></p>
<p>Low-Voltage I/O Expander (TCA6408A) data sheet: <a class="reference external" href="attachments/945057235/1060606005.pdf">tca6408a.pdf</a></p>
</section>
<section id="key-acronyms">
<span id="avedexternaldevicecontrol-axc-proxydriver-keyacronyms"></span><h3>Key Acronyms<a class="headerlink" href="#key-acronyms" title="Permalink to this headline">¶</a></h3>
<table class="relative-table wrapped confluenceTable" style="width: 24.6106%;"><colgroup><col style="width: 14.5622%;"/><col style="width: 85.464%;"/></colgroup><tbody><tr><th class="confluenceTh">Acronym</th><th class="confluenceTh">Definition</th></tr><tr><td class="confluenceTd">QSFP</td><td class="confluenceTd">Quad Small Form-Factor Pluggable</td></tr><tr><td class="confluenceTd">SFF</td><td class="confluenceTd">Small Form Factor</td></tr><tr><td class="confluenceTd">QSFP56</td><td class="confluenceTd">QSFP - 200G Transceivers</td></tr><tr><td class="confluenceTd" colspan="1">MIO</td><td class="confluenceTd" colspan="1">Multiplexed I/O</td></tr></tbody></table>
</section>
<section id="qsfp-overview">
<span id="avedexternaldevicecontrol-axc-proxydriver-qsfpoverview"></span><h3>QSFP overview<a class="headerlink" href="#qsfp-overview" title="Permalink to this headline">¶</a></h3>
<p>QSFP is a compact, hot-pluggable transceiver used for data communications.</p>
<p>These transceiver modules are generally used to convert data signals to and from laser optic light for ethernet and other communication standards.</p>
<p>It interfaces networking hardware (such as AMD Versal™ V80) to a fiber optic cable, or passive electrical copper connection.</p>
<p>Versal V80 supports QSFP. There are 4 QSFP NIC ports/modules on Versal V80 and all, when present, shall be managed by AMC.</p>
</section>
</section>
<section id="muxed-device-fal">
<span id="avedexternaldevicecontrol-axc-proxydriver-muxeddevicefal"></span><h2>Muxed Device FAL<a class="headerlink" href="#muxed-device-fal" title="Permalink to this headline">¶</a></h2>
<p>The AXC Proxy Driver will call into the muxed device FAL. This layer will be responsible for abstracting the stages required in accessing the external, muxed devices, into simple read and write calls.</p>
<p>There are a number of stages in the control path to access a QSFP or other muxed device on V80. The following flow-chart diagrams outline each stage, and the proposed FW_IF API responsible for implementing the stages.</p>
<p><a class="drawio-diagram-image reference internal" href="_images/6552c0b0f92e3e9bfee36090142f707071d5b437.png"><img alt="image1" class="drawio-diagram-image" src="_images/6552c0b0f92e3e9bfee36090142f707071d5b437.png" style="width: 301px;"/></a></p>
<p><a class="drawio-diagram-image reference internal" href="_images/63b491c2ea4682330ebbbe327dcecb6328343887.png"><img alt="image2" class="drawio-diagram-image" src="_images/63b491c2ea4682330ebbbe327dcecb6328343887.png" style="width: 731px;"/></a></p>
</section>
<section id="api">
<span id="avedexternaldevicecontrol-axc-proxydriver-api"></span><h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<p>This will make use of the OSAL layer to create the proxy mutex and task.</p>
<p><strong>iAXC_Initialise</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>/**
 * @brief   Main initialisation point <span class="k">for</span> the AXC Proxy Driver
 *
 * @param   ucProxyId   Unique ID <span class="k">for</span> this Proxy driver
 * @param   ulTaskPrio  Priority of the Proxy driver task <span class="o">(</span><span class="k">if</span> RR disabled<span class="o">)</span>
 * @param   ulTaskStack Stack size of the Proxy driver task
 *
 * @return  OK          Proxy driver initialised correctly
 *          ERROR       Proxy driver not initialised, or was already initialised
 *
 * @note    Proxy drivers can have <span class="m">0</span> or more firmware interfaces
 */
int iAXC_Initialise<span class="o">(</span> uint8_t ucProxyId, uint32_t ulTaskPrio, uint32_t ulTaskStack <span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This will initialize a new external device within the AXC proxy driver, adding the device to its internally held linked list. AXC proxy will continually check the status and temperature of the newly added device, raising an event if the status of the
device changes.</p>
<p><strong>iAXC_AddExternalDevice</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>/**
 * @brief   Initialise new External device. AXC proxy will check status and temperature
 *          of this device.
 *
 * @param   pxExDeviceCfg    Pointer to external device config
 *
 * @return  OK               Callback successfully bound
 *          ERROR            Callback not bound
 *
 */
int iAXC_AddExternalDevice<span class="o">(</span> AXC_PROXY_DRIVER_EXTERNAL_DEVICE_CONFIG *pxExDeviceCfg <span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This API can be used to bind into a callback to be notified of events generated by the AXC proxy using the AEL library. The current supported events are:</p>
<ul class="simple">
<li><p><strong>AXC_PROXY_DRIVER_E_QSFP_PRESENT</strong></p></li>
<li><p><strong>AXC_PROXY_DRIVER_E_QSFP_NOT_PRESENT</strong></p></li>
</ul>
<div class="line-block">
<div class="line"><br/></div>
</div>
<p><strong>iAXC_BindCallback</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>/*
 * @brief   Bind into this proxy driver
 *
 * @param   pxCallback  Callback to <span class="nb">bind</span> into the proxy driver
 *
 * @return  OK          Callback successfully bound
 *          ERROR       Callback not bound
 *
 * @notes   None
 */
int iAXC_BindCallback<span class="o">(</span> AEL_CALLBACK *pxCallback <span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This will write a byte value to desired device memory map. This API will not trigger functionality within the internal task (as with other proxy drivers), instead, the data will be written directly to the device from the calling task.</p>
<p><strong>iAXC_SetByte</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>/**
 * @brief   Write byte value to desired External Device memory map
 *
 * @param   ucExDeviceId    External Device Unique ID
 * @param   ulPage          Page to be accessed within QSFP memory map
 *                          N/A <span class="k">for</span> DIMM
 * @param   ulByteOffset    Byte address/offset within memory map page
 * @param   ucValue         Value to be <span class="nb">set</span>
 *
 * @return  OK              Data passed to proxy driver successfully
 *          ERROR           Data not passed successfully
 *
 * @note    Byte offset range <span class="m">0</span>-127 will write a byte value to the lower page 00h.
 *
 *          Byte offset range <span class="m">127</span>-255 will write a byte value to the upper page.
 *          Use ulPage to specify which upper-page to be used.
 *
 */
int iAXC_SetByte<span class="o">(</span> uint8_t ucExDeviceId, uint32_t ulPage, uint32_t ulByteOffset, uint8_t ucValue <span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This will read a byte value from the desired device memory map. This API will not trigger functionality within the internal task (as with other proxy drivers), instead, the data will be read directly from the device from the calling task.</p>
<p><strong>iAXC_GetByte</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>/**
 * @brief   Read real-time byte value from desired External Device memory map
 *
 * @param   ucExDeviceId    External Device Unique ID
 * @param   ulPage          Page to be accessed within QSFP memory map
 *                          N/A <span class="k">for</span> DIMM
 * @param   ulByteOffset    Byte address/offset within memory map page
 * @param   pucValue        Pointer to retrieved value
 *
 * @return  OK              Data retrieved from proxy driver successfully
 *          ERROR           Data not retrieved successfully
 *
 * @note    Byte offset range <span class="m">0</span>-127 will <span class="nb">read</span> a byte value from the lower page 00h.
 *
 *          Byte offset range <span class="m">127</span>-255 will <span class="nb">read</span> a byte value from the upper page.
 *          Use ulPage to specify which upper-page to be used.
 */
int iAXC_GetByte<span class="o">(</span> uint8_t ucExDeviceId, uint32_t ulPage, uint32_t ulByteOffset, uint8_t *pucValue <span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This will read an entire memory map page from the desired QSFP. This API will not trigger functionality within the internal task (as with other proxy drivers), instead, the data will be read directly from the QSFP from the calling task.</p>
<p><strong>iAXC_GetPage</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>/**
 * @brief   Read real-time memory map from desired QSFP
 *
 * @param   ucExDeviceId    External Device Unique ID
 * @param   ulPage          Page to be retrieved within QSFP memory map
 * @param   pxData          Pointer to retrieved data
 *
 * @return  OK              Data retrieved from proxy driver successfully
 *          ERROR           Data not retrieved successfully
 *
 * @note    This API will <span class="k">return</span> the specified upper page from QSFP memory map
 */
int iAXC_GetPage<span class="o">(</span> uint8_t ucExDeviceId, uint32_t ulPage, AXC_PROXY_DRIVER_PAGE_DATA *pxData <span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This will read a desired IO control line from the desired QSFP. This API will not trigger functionality within the internal task (as with other proxy drivers), instead, the data will be read directly from the QSFP from the calling task.</p>
<p><strong>iAXC_GetSingleIoStatus</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>/**
 * @brief   Read single status from QSFP IO Expander
 *
 * @param   ucExDeviceId    External Device Unique ID
 * @param   xIoControlLine  IO control line to be <span class="nb">read</span>
 * @param   pucIoStatus     Pointer to retrieved value
 *
 * @return  OK              Data retrieved from proxy driver successfully
 *          ERROR           Data not retrieved successfully
 *
 */
int iAXC_GetSingleIoStatus<span class="o">(</span> uint8_t ucExDeviceId, AXC_PROXY_DRIVER_QSFP_IO xIoControlLine, uint8_t *pucIoStatus <span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This will read all IO control lines from the desired QSFP. This API will not trigger functionality within the internal task (as with other proxy drivers), instead, the data will be read directly from the QSFP from the calling task.</p>
<p><strong>iAXC_GetAllIoStatuses</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>/**
 * @brief   Read all statuses from QSFP IO Expander
 *
 * @param   ucExDeviceId    External Device Unique ID
 * @param   pxIoStatuses    Pointer to data to get
 *
 * @return  OK              Data retrieved from proxy driver successfully
 *          ERROR           Data not retrieved successfully
 *
 */
int iAXC_GetAllIoStatuses<span class="o">(</span> uint8_t ucExDeviceId, AXC_PROXY_DRIVER_QSFP_IO_STATUSES *pxIoStatuses <span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This will return temperature value from the desired external device. The reading of temperature values is implemented within the AXC proxy task, for each device that has been added. Calling this function will simply return the most up-to-date
temperature value for the desired device.</p>
<p><strong>iAXC_GetTemperature</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>/**
 * @brief   Read real-time temperature value from desired External Device memory map
 *
 * @param   ucExDeviceId    External Device Unique ID
 * @param   pfTemperature   Pointer to retrieved temperature value
 *
 * @return  OK              Data retrieved from proxy driver successfully
 *          ERROR           Data not retrieved successfully
 *
 * @note    pfTemperature   will be returned <span class="k">in</span> degrees Celsius
 */
int iAXC_GetTemperature<span class="o">(</span> uint8_t ucExDeviceId, float *pfTemperature <span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This will get the current state of the proxy driver.</p>
<p><strong>iAXC_GetState</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>/**
 * @brief   Gets the current state of the proxy driver
 *
 * @param   pxState         Pointer to the state
 *
 * @return  OK              If successful
 *          ERROR           If not successful
 */
int iAXC_GetState<span class="o">(</span> MODULE_STATE *pxState <span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This will print AXC proxy statistic counters and errors, useful for Debug.</p>
<p><strong>iAXC_PrintStatistics</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>/**
 * @brief   Print all the stats gathered by the application
 *
 * @return  OK          Stats retrieved from proxy driver successfully
 *          ERROR       Stats not retrieved successfully
 *
 */
int iAXC_PrintStatistics<span class="o">(</span> void <span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Example output from iAXC_PrintStatistics():</p>
<p><a class="confluence-embedded-image reference internal" href="_images/1069625921.png"><img alt="image3" class="confluence-embedded-image" src="_images/1069625921.png" style="height: 400px;"/></a></p>
<p>This will clear all AXC statistic counters back to zero, useful for Debug.</p>
<p><strong>iAXC_ClearStatistics</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>/**
 * @brief   Clear all the stats <span class="k">in</span> the application
 *
 * @return  OK          Stats cleared successfully
 *          ERROR       Stats not cleared successfully
 *
 */
int iAXC_ClearStatistics<span class="o">(</span> void <span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="sequence-diagrams">
<span id="avedexternaldevicecontrol-axc-proxydriver-sequencediagrams"></span><h2>Sequence Diagrams<a class="headerlink" href="#sequence-diagrams" title="Permalink to this headline">¶</a></h2>
<p>Three AXC API functions are called from the AMC main task (iAXC_Initialise, iAXC_BindCallback and iAXC_AddExternalDevice), when all the other proxies are being initialized.</p>
<p>iAXC_Initialise will create a shared proxy mutex, and the proxy task. iAXC_BindCallback will bind the appropriate top-level callback function.</p>
<p>iAXC_AddExternalDevice is called five times, each with a unique FAL handle for each external device. Each FAL object will be opened, and memory allocated to hold the handle, unique ID, temperature and status of each device.</p>
<p>Note: It is the (top-level) applications responsibility to add the required number of External Devices, with unique FAL handles for each device.</p>
<p><a class="drawio-diagram-image reference internal" href="_images/d81d45db394cd6292cb73755acf59282803b5439.png"><img alt="image4" class="drawio-diagram-image" src="_images/d81d45db394cd6292cb73755acf59282803b5439.png" style="width: 961px;"/></a></p>
<p>The task within AXC proxy has 3 main responsibilities:</p>
<ul class="simple">
<li><p>Update the temperature value of each device.</p></li>
<li><p>Update the status (Present or not present) of each QSFP.</p></li>
<li><p>Raise an event if the QSFP status has changed (Present to not present, and vice versa).</p></li>
</ul>
<div class="line-block">
<div class="line"><br/></div>
</div>
<p><a class="drawio-diagram-image reference internal" href="_images/b7afd65103ffd842a1bf262b0d933316425a0109.png"><img alt="image5" class="drawio-diagram-image" src="_images/b7afd65103ffd842a1bf262b0d933316425a0109.png" style="width: 801px;"/></a></p>
</section>
<section id="examples">
<span id="avedexternaldevicecontrol-axc-proxydriver-examples"></span><h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>This function should only be called once. It requires a unique ID for the proxy, used for signaling new events from the proxy, along with proxy driver task priority and stack size.</p>
<p><strong>iAQC_Initialise Example</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="o">(</span> <span class="nv">OK</span> <span class="o">==</span> iAXC_Initialise<span class="o">(</span> AMC_EVENT_UNIQUE_ID_AXC, AMC_TASK_PRIO_DEFAULT, AMC_TASK_DEFAULT_STACK <span class="o">)</span> <span class="o">)</span>
<span class="o">{</span>
    AMC_PRINTF<span class="o">(</span> <span class="s2">"AXC Proxy Driver initialised\r\n"</span> <span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
<span class="k">else</span>
<span class="o">{</span>
    AMC_PRINTF<span class="o">(</span> <span class="s2">"Error initialising AXC Proxy Driver\r\n"</span> <span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Define a function based on the function pointer prototype and bind in using the API.</p>
<p><strong>iAQC_BindCallback Example</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>/* Define a callback to handle the events */
static int iAxcCallback<span class="o">(</span> EVL_SIGNAL *pxSignal <span class="o">)</span>
<span class="o">{</span>
    int <span class="nv">iStatus</span> <span class="o">=</span> ERROR<span class="p">;</span>

    <span class="k">if</span><span class="o">(</span> <span class="o">(</span> NULL !<span class="o">=</span> pxSignal <span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span> <span class="nv">AMC_EVENT_UNIQUE_ID_AXC</span> <span class="o">==</span> pxSignal-&gt;ucModule <span class="o">)</span> <span class="o">)</span>
    <span class="o">{</span>
        switch<span class="o">(</span> pxSignal-&gt;ucEventType <span class="o">)</span>
        <span class="o">{</span>
        <span class="k">case</span> AXC_PROXY_DRIVER_E_QSFP_PRESENT:
        <span class="o">{</span>
            /* TODO: handle event */
            <span class="nv">iStatus</span> <span class="o">=</span> OK<span class="p">;</span>
            break<span class="p">;</span>
        <span class="o">}</span>
        <span class="k">case</span> AXC_PROXY_DRIVER_E_QSFP_NOT_PRESENT:
        <span class="o">{</span>
            /* TODO: handle event */
            <span class="nv">iStatus</span> <span class="o">=</span> OK<span class="p">;</span>
            break<span class="p">;</span>
        <span class="o">}</span>
        default:
            break<span class="p">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> iStatus<span class="p">;</span>
<span class="o">}</span>

/* Bind into the callback during the application initialisation */
<span class="k">if</span><span class="o">(</span> <span class="nv">OK</span> <span class="o">==</span> iAXC_BindCallback<span class="o">(</span> <span class="p">&amp;</span>iAxcCallback <span class="o">)</span> <span class="o">)</span>
<span class="o">{</span>
    AMC_PRINTF<span class="o">(</span> <span class="s2">"AXC Proxy Driver initialised and bound\r\n"</span> <span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
<span class="k">else</span>
<span class="o">{</span>
    AMC_PRINTF<span class="o">(</span> <span class="s2">"Error binding to AXC Proxy Driver\r\n"</span> <span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>To add a new external device, pass in a pointer to a device config structure. This should include a handle to a FW_IF (already created and initialized), and a unique ID for the device.</p>
<p><strong>iAQC_AddQsfpDevice Example</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>/* AXC Device configs */
AXC_PROXY_DRIVER_EXTERNAL_DEVICE_CONFIG <span class="nv">xQsfpDevice1</span> <span class="o">=</span> <span class="o">{</span> <span class="p">&amp;</span>xQsfpIf1, <span class="m">1</span> <span class="o">}</span><span class="p">;</span>
AXC_PROXY_DRIVER_EXTERNAL_DEVICE_CONFIG <span class="nv">xQsfpDevice2</span> <span class="o">=</span> <span class="o">{</span> <span class="p">&amp;</span>xQsfpIf2, <span class="m">2</span> <span class="o">}</span><span class="p">;</span>
AXC_PROXY_DRIVER_EXTERNAL_DEVICE_CONFIG <span class="nv">xQsfpDevice3</span> <span class="o">=</span> <span class="o">{</span> <span class="p">&amp;</span>xQsfpIf3, <span class="m">3</span> <span class="o">}</span><span class="p">;</span>
AXC_PROXY_DRIVER_EXTERNAL_DEVICE_CONFIG <span class="nv">xQsfpDevice4</span> <span class="o">=</span> <span class="o">{</span> <span class="p">&amp;</span>xQsfpIf4, <span class="m">4</span> <span class="o">}</span><span class="p">;</span>
AXC_PROXY_DRIVER_EXTERNAL_DEVICE_CONFIG <span class="nv">xDimmDevice</span>  <span class="o">=</span> <span class="o">{</span> <span class="p">&amp;</span>xDimmIf, <span class="m">5</span> <span class="o">}</span><span class="p">;</span>

<span class="k">if</span><span class="o">(</span> <span class="o">(</span> <span class="nv">OK</span> <span class="o">==</span> iAXC_AddExternalDevice<span class="o">(</span> <span class="p">&amp;</span>xQsfpDevice1 <span class="o">)</span> <span class="o">)</span> <span class="o">&amp;&amp;</span>
    <span class="o">(</span> <span class="nv">OK</span> <span class="o">==</span> iAXC_AddExternalDevice<span class="o">(</span> <span class="p">&amp;</span>xQsfpDevice2 <span class="o">)</span> <span class="o">)</span> <span class="o">&amp;&amp;</span>
    <span class="o">(</span> <span class="nv">OK</span> <span class="o">==</span> iAXC_AddExternalDevice<span class="o">(</span> <span class="p">&amp;</span>xQsfpDevice3 <span class="o">)</span> <span class="o">)</span> <span class="o">&amp;&amp;</span>
    <span class="o">(</span> <span class="nv">OK</span> <span class="o">==</span> iAXC_AddExternalDevice<span class="o">(</span> <span class="p">&amp;</span>xQsfpDevice4 <span class="o">)</span> <span class="o">)</span> <span class="o">&amp;&amp;</span>
    <span class="o">(</span> <span class="nv">OK</span> <span class="o">==</span> iAXC_AddExternalDevice<span class="o">(</span> <span class="p">&amp;</span>xDimmDevice <span class="o">)</span> <span class="o">)</span> <span class="o">)</span>
<span class="o">{</span>
    AMC_PRINTF<span class="o">(</span> <span class="s2">"AXC Proxy Driver, external devices added\r\n"</span> <span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
<span class="k">else</span>
<span class="o">{</span>
    AMC_PRINTF<span class="o">(</span> <span class="s2">"Error adding external devices to AXC Proxy Driver\r\n"</span> <span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Example of setting byte 127, within page 00h of QSFP 1, to a value of 1. The parameters can be adjusted to set a different byte value, as required.</p>
<p><strong>iAQC_SetByte Example</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>uint8_t <span class="nv">iQsfpId</span> <span class="o">=</span> <span class="m">1</span><span class="p">;</span>
uint32_t <span class="nv">iPageNum</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
uint32_t <span class="nv">iByteOffset</span> <span class="o">=</span> <span class="m">127</span><span class="p">;</span>
uint8_t <span class="nv">ucByteValue</span> <span class="o">=</span> <span class="m">1</span><span class="p">;</span>

<span class="k">if</span><span class="o">(</span> OK !<span class="o">=</span> iAXC_SetByte<span class="o">(</span> iQsfpId, iPageNum, iByteOffset, ucByteValue <span class="o">)</span> <span class="o">)</span>
<span class="o">{</span>
    AXC_DBG_PRINTF<span class="o">(</span> <span class="s2">"Error setting memory byte\r\n"</span> <span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
<span class="k">else</span>
<span class="o">{</span>
    AXC_DBG_PRINTF<span class="o">(</span> <span class="s2">"Memory byte (%d) from page (%d) set successfully \r\n"</span>, iByteOffset, iPageNum <span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Example of reading byte 127, from page 00h of QSFP 1. The parameters can be adjusted to read a different byte value, as required.</p>
<p><strong>iAQC_GetByte Example</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>uint8_t <span class="nv">iQsfpId</span> <span class="o">=</span> <span class="m">1</span><span class="p">;</span>
uint32_t <span class="nv">iPageNum</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
uint32_t <span class="nv">iByteOffset</span> <span class="o">=</span> <span class="m">127</span><span class="p">;</span>
uint8_t <span class="nv">ucByteValue</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>

<span class="k">if</span><span class="o">(</span> OK !<span class="o">=</span> iAXC_GetByte<span class="o">(</span> iQsfpId, iPageNum, iByteOffset, <span class="p">&amp;</span>ucByteValue <span class="o">)</span> <span class="o">)</span>
<span class="o">{</span>
    AXC_DBG_PRINTF<span class="o">(</span> <span class="s2">"Error retrieving memory byte\r\n"</span> <span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
<span class="k">else</span>
<span class="o">{</span>
    AXC_DBG_PRINTF<span class="o">(</span> <span class="s2">"Retrieved memory byte, value (hex): 0x%02X\r\n"</span>, ucByteValue <span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Example of reading entire upper page 00h of QSFP 1. The parameters can be adjusted to read a different page, as required.</p>
<p><strong>iAQC_GetPage Example</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>uint8_t <span class="nv">iQsfpId</span> <span class="o">=</span> <span class="m">1</span><span class="p">;</span>
uint32_t <span class="nv">iPageNum</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
AXC_PROXY_DRIVER_QSFP_PAGE_DATA <span class="nv">xTestPage</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="m">0</span> <span class="o">}</span> <span class="o">}</span><span class="p">;</span>
int <span class="nv">i</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>

<span class="k">if</span><span class="o">(</span> OK !<span class="o">=</span> iAXC_GetPage<span class="o">(</span> iQsfpId, iPageNum, <span class="p">&amp;</span>xTestPage <span class="o">)</span> <span class="o">)</span>
<span class="o">{</span>
    AXC_DBG_PRINTF<span class="o">(</span> <span class="s2">"Error retrieving QSFP memory page\r\n"</span> <span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
<span class="k">else</span>
<span class="o">{</span>
    AXC_DBG_PRINTF<span class="o">(</span> <span class="s2">"Retrieved QSFP memory page, values: \r\n"</span> <span class="o">)</span><span class="p">;</span>

    <span class="k">for</span><span class="o">(</span> <span class="nv">i</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span> i &lt; xTestPage.ulPageDataSize<span class="p">;</span> i++ <span class="o">)</span>
    <span class="o">{</span>
        vOSAL_Printf<span class="o">(</span> <span class="s2">"0x%02X "</span>, xTestPage.pucPageData<span class="o">[</span> i <span class="o">]</span> <span class="o">)</span><span class="p">;</span>
    <span class="o">}</span>

    vOSAL_Printf<span class="o">(</span> <span class="s2">"\r\n"</span> <span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Example of reading MODSEL status of QSFP 1. The parameters can be adjusted to read a different IO status line, as required.</p>
<p><strong>iAQC_GetSingleIoStatus Example</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>uint8_t <span class="nv">iQsfpId</span> <span class="o">=</span> <span class="m">1</span><span class="p">;</span>
AXC_PROXY_DRIVER_QSFP_IO <span class="nv">iIoCtrlId</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span> /* MODSEL */
uint8_t <span class="nv">ucIoStatusValue</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>

<span class="k">if</span><span class="o">(</span> OK !<span class="o">=</span> iAXC_GetSingleIoStatus<span class="o">(</span> iQsfpId, iIoCtrlId, <span class="p">&amp;</span>ucIoStatusValue <span class="o">)</span> <span class="o">)</span>
<span class="o">{</span>
    AXC_DBG_PRINTF<span class="o">(</span> <span class="s2">"Error retrieving QSFP IO expander status\r\n"</span> <span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
<span class="k">else</span>
<span class="o">{</span>
    AXC_DBG_PRINTF<span class="o">(</span> <span class="s2">"Retrieved QSFP IO expander status, value: %d\r\n"</span>, ucIoStatusValue <span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Example of reading all IO statuses from QSFP 1. The parameters can be adjusted to read from a different QSFP, as required.</p>
<p><strong>iAQC_GetAllIoStatuses Example</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>uint8_t <span class="nv">iQsfpId</span> <span class="o">=</span> <span class="m">1</span><span class="p">;</span>
AXC_PROXY_DRIVER_QSFP_IO_STATUSES <span class="nv">xTestStatuses</span> <span class="o">=</span> <span class="o">{</span> <span class="m">0</span> <span class="o">}</span><span class="p">;</span>

<span class="k">if</span><span class="o">(</span> OK !<span class="o">=</span> iAXC_GetAllIoStatuses<span class="o">(</span> iQsfpId, <span class="p">&amp;</span>xTestStatuses <span class="o">)</span> <span class="o">)</span>
<span class="o">{</span>
    AXC_DBG_PRINTF<span class="o">(</span> <span class="s2">"Error retrieving QSFP IO expander statuses\r\n"</span> <span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
<span class="k">else</span>
<span class="o">{</span>
    AXC_DBG_PRINTF<span class="o">(</span> <span class="s2">"Retrieved QSFP IO expander statuses\r\n"</span> <span class="o">)</span><span class="p">;</span>
    AXC_DBG_PRINTF<span class="o">(</span> <span class="s2">"MODSEL value: (%d)\r\n"</span>, xTestStatuses.ucModSel <span class="o">)</span><span class="p">;</span>
    AXC_DBG_PRINTF<span class="o">(</span> <span class="s2">"RESET  value: (%d)\r\n"</span>, xTestStatuses.ucReset <span class="o">)</span><span class="p">;</span>
    AXC_DBG_PRINTF<span class="o">(</span> <span class="s2">"LPMODE value: (%d)\r\n"</span>, xTestStatuses.ucLpMode <span class="o">)</span><span class="p">;</span>
    AXC_DBG_PRINTF<span class="o">(</span> <span class="s2">"MODPRS value: (%d)\r\n"</span>, xTestStatuses.ucModPrs <span class="o">)</span><span class="p">;</span>
    AXC_DBG_PRINTF<span class="o">(</span> <span class="s2">"INT    value: (%d)\r\n"</span>, xTestStatuses.ucInterrupt <span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Example of reading temperature value from QSFP 1. The parameters can be adjusted to read from a different device, as required.</p>
<p><strong>iAQC_GetTemperature Example</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>uint8_t <span class="nv">iQsfpId</span> <span class="o">=</span> <span class="m">1</span><span class="p">;</span>
float <span class="nv">fTemperatureByte</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>

<span class="k">if</span><span class="o">(</span> OK !<span class="o">=</span> iAXC_GetTemperature<span class="o">(</span> iQsfpId, <span class="p">&amp;</span>fTemperatureByte <span class="o">)</span> <span class="o">)</span>
<span class="o">{</span>
    AXC_DBG_PRINTF<span class="o">(</span> <span class="s2">"Error retrieving temperature\r\n"</span> <span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
<span class="k">else</span>
<span class="o">{</span>
    AXC_DBG_PRINTF<span class="o">(</span> <span class="s2">"Retrieved temperature value: (%f)\r\n"</span>, fTemperatureByte <span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br/></div>
</div>
<p>Page Revision: v. 37</p>
</section>
</section>
</div>
</div>
<footer><div aria-label="Footer" class="rst-footer-buttons" role="navigation">
<a accesskey="p" class="btn btn-neutral float-left" href="AVED%2BSensor%2BControl%2B%28ASC%29%2BProxy%2BDriver.html" rel="prev" title="AVED Sensor Control (ASC) Proxy Driver"><span aria-hidden="true" class="fa fa-arrow-circle-left"></span> Previous</a>
<a accesskey="n" class="btn btn-neutral float-right" href="Firmware%2BInterface%2B%28FW_IF%29%2BAbstraction%2BLayer.html" rel="next" title="Firmware Interface (FW_IF) Abstraction Layer">Next <span aria-hidden="true" class="fa fa-arrow-circle-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<p>© Copyright 2023, Advanced Micro Devices Inc.</p>
</div>
<div class="aem-Grid aem-Grid--16">
<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
<div class="container-fluid sub-footer">
<div class="row">
<div class="col-xs-24">
<p><a href="https://www.amd.com/en/corporate/copyright" target="_blank">Terms and Conditions</a> | <a href="https://www.amd.com/en/corporate/privacy" target="_blank">Privacy</a> | <a href="https://www.amd.com/en/corporate/cookies" target="_blank">Cookie Policy</a> | <a href="https://www.amd.com/en/corporate/trademarks" target="_blank">Trademarks</a> | <a href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf" target="_blank">Statement on Forced Labor</a> | <a href="https://www.amd.com/en/corporate/competition" target="_blank">Fair and Open Competition</a> | <a href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf" target="_blank">UK Tax Strategy</a> | <a href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA" target="_blank">Inclusive Terminology</a> | <a class="ot-sdk-show-settings" href="#cookiessettings">Cookies Settings</a></p>
</div>
</div>
</div>
</div>
</div>



  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
</div>
</div>
</section>
</div>
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
<script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>
</body>
</html>