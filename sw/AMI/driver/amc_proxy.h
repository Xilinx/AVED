// SPDX-License-Identifier: GPL-2.0-only
/*
 * amc_proxy.h - The AMC proxy layer used to abstract away the transport.
 *
 * Copyright (c) 2023 Advanced Micro Devices, Inc. All rights reserved.
 */

#ifndef _AMC_PROXY_H_
#define _AMC_PROXY_H_

#include <linux/types.h>
#include <linux/errno.h>

#include "ami.h"
#include "fw_if.h"
#include "fw_if_gcq.h"


/*****************************************************************************/
/* Defines                                                                  */
/*****************************************************************************/
#define AMC_PROXY_REQUEST_SIZE	        (512)
#define AMC_PROXY_RESPONSE_SIZE	        (16)


/*****************************************************************************/
/* Typedefs                                                                  */
/*****************************************************************************/

/**
 * typedef amc_proxy_event_callback - the function pointer defintion for the event callback
 * @proxy_id: the associated proxy id.
 * @event_id: the event that cause the callback to be invoked.
 * @arg: void ptr containing the proxy command used to raise request.
 *
 * Return: errno or success code.
 */
typedef int (amc_proxy_event_callback)(uint8_t proxy_id, uint8_t event_id, void* arg);


/*****************************************************************************/
/* Enums                                                                     */
/*****************************************************************************/

/**
 * enum amc_proxy_event - the events generated by the amc proxy layer
 * @AMC_PROXY_EVENT_RESPONSE_COMPLETE: completion event
 * @AMC_PROXY_EVENT_RESPONSE_TIMEOUT: timeout event
 */
enum amc_proxy_event {
        AMC_PROXY_EVENT_RESPONSE_COMPLETE = 0,
        AMC_PROXY_EVENT_RESPONSE_TIMEOUT,

        MAX_AMC_PROXY_EVENT
};

/**
 * enum amc_proxy_cmd_sensor_request - sensor request types
 * @AMC_PROXY_CMD_SENSOR_REQUEST_UNKNOWN: the default unknown value
 * @AMC_PROXY_CMD_SENSOR_REQUEST_GET_SIZE: get the size
 * @AMC_PROXY_CMD_SENSOR_REQUEST_GET_SDR: get an SDR
 * @AMC_PROXY_CMD_SENSOR_REQUEST_GET_SINGLE_SDR: get a single SDR
 * @AMC_PROXY_CMD_SENSOR_REQUEST_ALL_SDR: get all SDR
 */
enum amc_proxy_cmd_sensor_request {
        AMC_PROXY_CMD_SENSOR_REQUEST_UNKNOWN = -EINVAL,
        AMC_PROXY_CMD_SENSOR_REQUEST_GET_SIZE = 0x1,
        AMC_PROXY_CMD_SENSOR_REQUEST_GET_SDR,
        AMC_PROXY_CMD_SENSOR_REQUEST_GET_SINGLE_SDR,
        AMC_PROXY_CMD_SENSOR_REQUEST_ALL_SDR,

        MAX_AMC_PROXY_CMD_SENSOR_REQUEST
};

/**
 * enum amc_proxy_cmd_sensor_repo - sensor repo request types
 * @AMC_PROXY_CMD_SENSOR_REPO_UNKNOWN: the default unknown value
 * @AMC_PROXY_CMD_SENSOR_REPO_GET_SIZE: get the size
 * @AMC_PROXY_CMD_SENSOR_REPO_BDINFO: get board info
 * @AMC_PROXY_CMD_SENSOR_REPO_TEMP: get temperature
 * @AMC_PROXY_CMD_SENSOR_REPO_VOLTAGE: get voltage
 * @AMC_PROXY_CMD_SENSOR_REPO_CURRENT: get current
 * @AMC_PROXY_CMD_SENSOR_REPO_POWER: get power
 * @AMC_PROXY_CMD_SENSOR_REPO_TOTAL_POWER: get total power
 * @AMC_PROXY_CMD_SENSOR_REPO_QSFP: get QSFP
 * @AMC_PROXY_CMD_SENSOR_REPO_FPT: get flash partition table
 * @AMC_PROXY_CMD_SENSOR_REPO_ALL: get all
 */
enum amc_proxy_cmd_sensor_repo {
        AMC_PROXY_CMD_SENSOR_REPO_UNKNOWN = -EINVAL,
        AMC_PROXY_CMD_SENSOR_REPO_GET_SIZE = 0,
        AMC_PROXY_CMD_SENSOR_REPO_BDINFO,
        AMC_PROXY_CMD_SENSOR_REPO_TEMP,
        AMC_PROXY_CMD_SENSOR_REPO_VOLTAGE,
        AMC_PROXY_CMD_SENSOR_REPO_CURRENT,
        AMC_PROXY_CMD_SENSOR_REPO_POWER,
        AMC_PROXY_CMD_SENSOR_REPO_TOTAL_POWER,
        AMC_PROXY_CMD_SENSOR_REPO_QSFP,
        AMC_PROXY_CMD_SENSOR_REPO_FPT,
        AMC_PROXY_CMD_SENSOR_REPO_ALL,

        MAX_AMC_PROXY_CMD_SENSOR_REPO
};

/**
 * enum amc_proxy_cmd_rw_request - type of request for read/write commands
 * @AMC_PROXY_CMD_RW_REQUEST_READ: read a value
 * @AMC_PROXY_CMD_RW_REQUEST_WRITE: write a value
*/
enum amc_proxy_cmd_rw_request {
        AMC_PROXY_CMD_RW_REQUEST_READ = 0,
        AMC_PROXY_CMD_RW_REQUEST_WRITE,

        MAX_AMC_PROXY_CMD_RW_REQUEST
};

/******************************************************************************************/
/* Structs                                                                                */
/******************************************************************************************/

/**
 * struct amc_proxy_sensor_request: the sensor request data
 *
 * @req: the request type
 * @repo: the repo type
 * @sensor_id: the sensor id
 * @length: the length of the response
 * @address: the address of memory to be populated with response
 */
struct amc_proxy_sensor_request {
        enum amc_proxy_cmd_sensor_request req;
        enum amc_proxy_cmd_sensor_repo repo;
        uint32_t sensor_id;
        uint32_t length;
        uint64_t address;
};

/**
 * struct amc_proxy_pdi_download_request: the pdi download request data
 *
 * @length: the length of the response
 * @address: the address of memory to be populated with response
 * @partition: partition number to flash to
 * @last_chunk: 1 to indicate that this is the last chunk
 * @chunk: current chunk number
 * @chunk_size: chunk size in KB
 *
 * If partition is equal to `FPT_UPDATE_MAGIC`, will update the FPT.
 */
struct amc_proxy_pdi_download_request {
        uint32_t length;
        uint64_t address;
        uint32_t partition;
        uint16_t last_chunk;
        uint16_t chunk;
        uint16_t chunk_size;
};

/**
 * struct amc_proxy_partition_copy_request: the partition copy request data
 * 
 * @src: source partition
 * @dest: destination partition
 * @length: length of PCI memory
 * @address: start offset of PCI memory
 *
 * Note that the length and address are used only by AMC to perform the copy
 * operation - data gets copied into the shared memory then to the destination
 * partition. This memory is not accessed by AMI.
 */
struct amc_proxy_partition_copy_request {
        uint32_t src;
        uint32_t dest;
        uint32_t length;
        uint64_t address;
};

/**
 * struct amc_proxy_hearbeat_request: the heartbeat request data
 *
 * @request_id: the id associated with the request/response
 */
struct amc_proxy_hearbeat_request {
        uint8_t request_id;
};

/**
 * struct amc_proxy_eeprom_rw_request: the eeprom read/write request data
 *
 * @type: either a read or a write
 * @address: the address of memory to be populated with data to be written or read
 * @length: the length of the read/write
 * @offset: offset into the eeprom address space
 */
struct amc_proxy_eeprom_rw_request {
    enum amc_proxy_cmd_rw_request type;
    uint64_t address;
    uint8_t length;
    uint8_t offset;
};

/**
 * struct amc_proxy_module_rw_request: the module read/write request data
 *
 * @type: either a read or a write
 * @address: the address of memory to be populated with data to be written or read
 * @device_id: the module device ID
 * @page: the page number to access
 * @offset: byte offset within page
 * @length: number of bytes to read/write
 */
struct amc_proxy_module_rw_request {
        enum amc_proxy_cmd_rw_request type;
        uint64_t address;
        uint8_t device_id;
        uint8_t page;
        uint8_t offset;
        uint8_t length;
};

/**
 * struct amc_proxy_identify_response: AMC/GCQ version data
 *
 * @ver_major: AMC major version number
 * @ver_minor: AMC minor version number
 * @ver_patch: AMC patch version number
 * @local_changes: 0 for no change, 1 for changes
 * @dev_commits: AMC number of dev commits
 * @link_ver_major: GCQ major version number
 * @link_ver_minor: GCQ minor version number
 */
struct amc_proxy_identify_response {
        uint8_t ver_major;
        uint8_t ver_minor;
        uint8_t ver_patch;
        uint8_t local_changes;
        uint16_t dev_commits;
        uint8_t link_ver_major;
        uint8_t link_ver_minor;
};

/**
 * struct amc_proxy_heartbeat_response: the heartbeat response data
 *
 * @request_id: the id associated with the request/response
 */
struct amc_proxy_heartbeat_response {
        uint8_t request_id;
};

/**
 * struct amc_proxy_cmd_struct: dynamically allocated per command request/response
 *
 * @cmd_list: used to store the list element
 * @cmd_complete: conditional variable to be signalled via callback
 * @cmd_complete_heartbeat: conditional variable to be signalled via callback for heartbeat msg
 * @cmd_timeout_jiffies: jiffies to wait for response until timing out command
 * @cmd_rcode: the return code
 * @cmd_cid: the unique id associated with the command
 * @cmd_response: used to store the command response
 * @cmd_response_code: command status set by AMC
 * @cmd_arg: opaque void ptr
 * @cmd_fw_if_gcq: copy of the fw interface handle
 * @cmd_suppress_dbg: flag to indicate debug suppressed for command
 * @cmd_opcode: opcode associated with the command
 * @timed_out: boolean indicating if this command timed out
 */
struct amc_proxy_cmd_struct{
	struct list_head        cmd_list;
	struct completion       cmd_complete;
        struct completion       cmd_complete_heartbeat;
	uintptr_t               cmd_timeout_jiffies;
	int                     cmd_rcode;
       	uint16_t                cmd_cid;
       	uint64_t                cmd_response;
        uint32_t                cmd_response_code;
       	void                    *cmd_arg;
        FW_IF_CFG               *cmd_fw_if_gcq;
        bool                    cmd_suppress_dbg;
        uint32_t                cmd_opcode;
        bool                    timed_out;
};


/******************************************************************************************/
/* Public Functions                                                                       */
/******************************************************************************************/

/**
 * amc_proxy_init() - Initialise the amc proxy layer
 *
 * @proxy_id: unique id to the proxy layer
 * @fw_if_handle: handle to the fw interface
 *
 * Return: The errno return code
 */
int amc_proxy_init(uint8_t proxy_id, FW_IF_CFG *fw_if_handle);

/**
 * amc_proxy_bind_callback() - Bind in the an event callback
 *
 * @fw_if_handle: handle to the fw interface
 * @event_cb: callback to be invoked when an event is generated
 *
 * Return: The errno return code
 */
int amc_proxy_bind_callback(FW_IF_CFG *fw_if_handle, amc_proxy_event_callback *event_cb);

/**
 * amc_proxy_close() - Close the amc proxy layer and free up resources
 *
 * @fw_if_handle: handle to the fw interface
 * 
 * Return: The errno return code
 */
int amc_proxy_close(const FW_IF_CFG *fw_if_handle);

/**
 * amc_proxy_request_abort() - Abort a request already in progress
 *
 * @cmd: the proxy command structure
 *
 * Return: The errno return code
 */
int amc_proxy_request_abort(struct amc_proxy_cmd_struct *cmd);

/**
 * amc_proxy_request_identity() - Request the identify
 *
 * @cmd: the proxy command structure
 * 
 * Return: The errno return code
 */
int amc_proxy_request_identity(struct amc_proxy_cmd_struct *cmd);

/**
 * amc_proxy_request_sensor() - Request sensor data based on the populated structure
 *
 * @cmd: the proxy command structure
 * @sensor: a structure populated with the request, repo type & sensor ID
 *
 * Return: The errno return code
 *
 */
int amc_proxy_request_sensor(struct amc_proxy_cmd_struct *cmd, struct amc_proxy_sensor_request *sensor);

/**
 * amc_proxy_request_pdi_download() - Request PDI download based on the populated structure
 *
 * @cmd: the proxy command structure
 * @pdi_download: a structure populated with the PDI download request
 *
 * Return: The errno return code
 *
 */
int amc_proxy_request_pdi_download(struct amc_proxy_cmd_struct *cmd,
                                   struct amc_proxy_pdi_download_request *pdi_download);

/**
 * amc_proxy_request_device_boot() - Select device boot partition
 * 
 * @cmd: the proxy command structure
 * @device_boot: a structure populated with the boot select request
 * 
 * This request uses the same structure as the PDI download.
 *
 * Return: The errno return code
 */
int amc_proxy_request_device_boot(struct amc_proxy_cmd_struct *cmd,
                                   struct amc_proxy_pdi_download_request *device_boot);

/**
 * amc_proxy_request_partition_copy() - Copy one partition to another
 * 
 * @cmd: the proxy command structure
 * @partition_copy: a structure populated with the partition copy request
 * 
 * Return: The errno return code
 */
int amc_proxy_request_partition_copy(struct amc_proxy_cmd_struct *cmd,
                                struct amc_proxy_partition_copy_request *partition_copy);

/**
 * amc_proxy_request_heartbeat() - heartbeat request
 * 
 * @cmd: the proxy command structure
 * @heartbeat: a structure populated with the heartbeat request
 * 
 * Return: The errno return code
 */
int amc_proxy_request_heartbeat(struct amc_proxy_cmd_struct *cmd,
                                struct amc_proxy_hearbeat_request *heartbeat);

/**
 * amc_proxy_request_eeprom_read_write() - eeprom read/write request
 *
 * @cmd: the proxy command structure
 * @eeprom_rw: a structure populated with the eeprom read/write request
 *
 * Return: The errno return code
 */
int amc_proxy_request_eeprom_read_write(struct amc_proxy_cmd_struct *cmd,
                                        struct amc_proxy_eeprom_rw_request *eeprom_rw);

/**
 * amc_proxy_request_module_read_write() - module read/write request
 *
 * @cmd: the proxy command structure
 * @module_rw: a structure populated with the module read/write request
 *
 * Return: The errno return code
 */
int amc_proxy_request_module_read_write(struct amc_proxy_cmd_struct *cmd,
                                        struct amc_proxy_module_rw_request *module_rw);

/**
 * amc_proxy_get_response_identity() - retrieve the identity response
 *
 * @cmd: the proxy command structure
 * @identity: the structure to be populated with the major/minor version
 *
 * Return: The errno return code
 */
int amc_proxy_get_response_identity(struct amc_proxy_cmd_struct *cmd, 
                                    struct amc_proxy_identify_response *identity);

/**
 * amc_proxy_get_response_sensor() - check if a valid sensor response has been received
 *
 * @cmd: the proxy command structure
 * 
 * As part of a sensor request an address and length is passed to be populated, this
 * api is to check if its now valid to consume that data.
 *
 * Return:  The errno return code
 */
int amc_proxy_get_response_sensor(struct amc_proxy_cmd_struct *cmd);

/**
 * amc_proxy_get_response_pdi_download() - retrieve the pdi download response
 *
 * @cmd: the proxy command structure
 *
 * As part of a pdi download request an address and length is passed containing
 * the address & length of the data, this api to check if the download has been
 * successfull.
 *
 * Return: The errno return code
 */
int amc_proxy_get_response_pdi_download(struct amc_proxy_cmd_struct *cmd);

/**
 * amc_proxy_get_response_device_boot() - retrieve the boot select response
 *
 * @cmd: the proxy command structure
 *
 * Return: The errno return code
 */
int amc_proxy_get_response_device_boot(struct amc_proxy_cmd_struct *cmd);

/**
 * amc_proxy_get_response_partition_copy() - retrieve the partition copy response
 * 
 * @cmd: the proxy command structure
 * 
 * Return: The errno return code
 */
int amc_proxy_get_response_partition_copy(struct amc_proxy_cmd_struct *cmd);

/**
 * amc_proxy_get_response_heartbeat() - retrieve the heartbeat response
 * 
 * @cmd: the proxy command structure
 * @heartbeat: the structure to be populated with the response
 * 
 * Return: The errno return code
 */
int amc_proxy_get_response_heartbeat(struct amc_proxy_cmd_struct *cmd,
                                     struct amc_proxy_heartbeat_response *heartbeat);

/**
 * amc_proxy_get_response_eeprom_read_write() - retrieve the eeprom read/write response
 *
 * @cmd: the proxy command structure
 *
 * Return: The errno return code
 */
int amc_proxy_get_response_eeprom_read_write(struct amc_proxy_cmd_struct *cmd);

/**
 * amc_proxy_get_response_module_read_write() - retrieve the module read/write response
 *
 * @cmd: the proxy command structure
 *
 * Return: The errno return code
 */
int amc_proxy_get_response_module_read_write(struct amc_proxy_cmd_struct *cmd);

#endif /* _AMC_PROXY_H_ */
